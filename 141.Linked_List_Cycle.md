# step1
## 実装
```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        visited = set()
        while head:
            if head in visited:
                return True
            visited.add(head)
            head = head.next
        return False
```
## 感想
- 訪れたノードの情報を保存して、訪問済みかを確認しながらノードを進めていく発想で解いた。

# step2
## 実装
```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        fast = head
        slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
```
## 感想
- フロイドの循環検出を使って解くと、訪れたノードの情報を保存せずに済むと分かったので、使ってみることにした。
- fastが2つノードを進めるので、初期状態とサイクルがない場合の末端の状態で範囲外アクセスしないようにループの条件の設定に注意した。

# step3
## 実装
```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        fast = head  # fast goes 1 step at a time
        slow = head  # slow goes 2 steps at a time
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
```
## 感想
- step1でしか使わなかったが、setの使い方とハッシュテーブルの実装の仕方は確認して、次の問題に進む。
